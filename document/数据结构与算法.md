# 数据结构和算法的概念

> 广义概念

数据结构就是指一组数据的存储结构。算法就是操作数据的一组方法。

> 狭义概念

是指某些著名的数据结构和算法，比如队列、栈、堆、二分查找、动态规划等



> 为什么大部分书都把这两个东西放到一块儿来讲呢?

**数据结构是为算法服务的，算法要作用在特定的数据结构之上**

![img](image/dataStructure/数据结构和算法.jpg)

> 10个常用的数据结构

数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie树

> 10个常用的算法

递归，排序，二分查找，搜索，哈希算法，贪心算法，分支算法，回溯算法，动态规划，字符串匹配算法

# 复杂度分析

> 大O时间复杂度

大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示**代码执行时间随数据规模增长的变化趋势**，所以，也叫作**渐进时间复杂度**

## 时间复杂度分析

> 1. 只关注循环执行次数最多的一段代码

大 O 这种复杂度表示方法只是表示一种变化趋势。我们通常会忽略掉公式中的常量、低阶、系数，只需要记录一个最大阶的量级就可以了。

**我们在分析一个算法、一段代码的时间复杂度的时候，也只关注循环执行次数最多的那一段代码就可以了**



> 2. 加法法则：总复杂度等于量级最大的那段代码的复杂度



> 3. 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

### 几种常见时间复杂度实例分析

![img](image/dataStructure/时间复杂度量级.jpg)

对于刚罗列的复杂度量级，我们可以粗略地分为两类，多项式量级和非多项式量级。其中，非多项式量级只有两个：O(2n) 和 O(n!)。

#### 1. O(1)

首先你必须明确一个概念，O(1) 只是常量级时间复杂度的一种表示方法，并不是指只执行了一行代码。比如这段代码，即便有 3 行，它的时间复杂度也是 O(1），而不是 O(3)。

```java
 int i = 8;
 int j = 6;
 int sum = i + j;
```

**一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)**

#### 2. O(logn)、O(nlogn)

对数阶时间复杂度非常常见，同时也是最难分析的一种时间复杂度。我通过一个例子来说明一下。

```java

 i=1;
 while (i <= n)  {
   i = i * 2;
 }
//x=log2n，所以，这段代码的时间复杂度就是 O(log2n)。


 i=1;
 while (i <= n)  {
   i = i * 3;
 }
//这段代码的时间复杂度就是 O(log3n)。
```

在对数阶时间复杂度的表示方法里，我们忽略对数的“底”，统一表示为 O(logn)。

#### 3. O(m+n)  O(m*n)

代码的复杂度由**两个数据的规模**来决定

```java

int cal(int m, int n) {
  int sum_1 = 0;
  int i = 1;
  for (; i < m; ++i) {
    sum_1 = sum_1 + i;
  }

  int sum_2 = 0;
  int j = 1;
  for (; j < n; ++j) {
    sum_2 = sum_2 + j;
  }

  return sum_1 + sum_2;
}
```

![img](image/dataStructure/时间复杂度比较.jpg)



### 时间复杂度的情况

#### 最好时间复杂度

最好情况时间复杂度就是，在最理想的情况下，执行这段代码的时间复杂度。在数组长度为N的数组中查找某个数据，在最理想的情况下，要查找的变量 x 正好是数组的第一个元素，这个时候对应的时间复杂度就是最好情况时间复杂度。

#### 最坏时间复杂度

最坏情况时间复杂度就是，在最糟糕的情况下，执行这段代码的时间复杂度。在数组长度为N的数组中查找某个数据，如果数组中没有要查找的变量 x，我们需要把整个数组都遍历一遍才行，所以这种最糟糕情况下对应的时间复杂度就是最坏情况时间复杂度。

#### 平均时间复杂度

要查找的变量 x 在数组中的位置，有 n+1 种情况：在数组的 0～n-1 位置中和不在数组中。我们把每种情况下，查找需要遍历的元素个数累加起来，然后再除以 n+1，就可以得到需要遍历的元素个数的平均值

![img](image/dataStructure/平均时间复杂度.jpg)

#### 均摊时间复杂度

均摊时间复杂度就是一种特殊的平均时间复杂度

在代码执行的所有复杂度情况中绝大部分是低级别的复杂度，个别情况是高级别复杂度且发生具有时序关系时，可以将个别高级别复杂度均摊到低级别复杂度上。基本上均摊结果就等于低级别复杂度。

## 空间复杂度分析

空间复杂度全称就是**渐进空间复杂度**（asymptotic space complexity），**表示算法的存储空间与数据规模之间的增长关系**

# 数组

> 概念

**数组（Array）**是一种**线性表**数据结构。它用一组**连续的内存空间**，来存储一组具有**相同类型**的数据。

线性表：数组，链表，队列，栈等

非线性表：二叉树，堆，树

> 数组和容器的选择？

对于业务开发，直接使用容器就足够了，省时省力。毕竟损耗一丢丢性能，完全不会影响到系统整体的性能。但如果你是做一些非常底层的开发，比如开发网络框架，性能的优化需要做到极致，这个时候数组就会优于容器，成为首选。

> 为什么数组的下标是从0开始的？

如果用 a 来表示数组的首地址，a[0]就是偏移为 0 的位置，也就是首地址，a[k]就表示偏移 k 个 type_size 的位置，所以计算 a[k]的内存地址只需要用这个公式：

```c++
a[k]_address = base_address + k * type_size
```

但是，如果数组从 1 开始计数，那我们计算数组元素 a[k]的内存地址就会变为：

```c++
a[k]_address = base_address + (k-1)*type_size
```

**从 1 开始编号，每次随机访问数组元素都多了一次减法运算，对于 CPU 来说，就是多了一次减法指令。**

# 链表

经典的链表应用场景： LRU 缓存淘汰算法



**缓存**是一种提高数据读取性能的技术，在硬件设计、软件开发中都有着非常广泛的应用，比如常见的 CPU 缓存、数据库缓存、浏览器缓存等等。



> 链表的分类

1. 单向链表
2. 循环链表
3. 双向链表（LinkedHashMap）

**对于执行较慢的程序，可以通过消耗更多的内存（空间换时间）来进行优化；而消耗过多内存的程序，可以通过消耗更多的时间（时间换空间）来降低内存的消耗。**

## 链表 VS 数组性能大比拼

![img](image/dataStructure/链表-数组比较.jpg)

数组简单易用，在实现上使用的是连续的内存空间，可以借助 CPU 的缓存机制，预读数组中的数据，所以访问效率更高。而链表在内存中并不是连续存储，所以对 CPU 缓存不友好，没办法有效预读。

## 链表代码技巧

> 技巧一：理解指针或引用的含义

将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。

> 技巧二：警惕指针丢失和内存泄漏



> 技巧三：利用哨兵简化实现难度

如果我们引入哨兵结点，在任何时候，不管链表是不是空，head 指针都会一直指向这个哨兵结点。我们也把这种有哨兵结点的链表叫带头链表。相反，没有哨兵结点的链表就叫作不带头链表。



![img](image/dataStructure/带头链表.jpg)

哨兵结点是不存储数据的。因为哨兵结点一直存在，所以插入第一个结点和插入其他结点，删除最后一个结点和删除其他结点，都可以统一为相同的代码实现逻辑了。



> 技巧四：重点留意边界条件处理



> 技巧五：举例画图，辅助思考

## 常见链表操作

### 单链表反转





### 链表中环的检测



### 两个有序的链表合并



### 删除链表倒数第n个几点



### 求链表的中间结点



# 队列

## 阻塞队列

**阻塞队列**其实就是在队列基础上增加了阻塞操作。简单来说，就是在队列为空的时候，从队头取数据会被阻塞。因为此时还没有数据可取，直到队列中有了数据才能返回；如果队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回。

## 并发队列

线程安全的队列我们叫作**并发队列**。最简单直接的实现方式是直接在 enqueue()、dequeue() 方法上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或者取操作。实际上，基于数组的循环队列，利用 CAS 原子操作，可以实现非常高效的并发队列。这也是循环队列比链式队列应用更加广泛的原因。



# 递归

## 递归需要满足的三个条件

1. 一个问题的解可以分解为几个子问题的解
2. 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样
3. 存在递归终止条件

**写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码**

**编写递归代码的关键是，只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。**



## 递归的注意事项

1. 递归代码要警惕堆栈溢出
2. 递归代码要警惕重复计算



# 排序

**排序算法的执行效率：**

1. 最好情况、最坏情况、平均情况时间复杂度
2. 时间复杂度的系数、常数 、低阶
   1. 在对同一阶时间复杂度的排序算法性能对比的时候，我们就要把系数、常数、低阶也考虑进来。
3. 比较次数和交换（或移动）次数



排序算法的稳定性：

1. **稳定的排序算法**：大小相同的数值比较后位置不发生变化的排序算法。
2. **不稳定的排序算法**：大小相同的数值比较厚位置发生交换的排序算法。



>  **有序度：数组中具有有序关系的元素对的个数**

```
对应的数学表达式
有序元素对：a[i] <= a[j], 如果i < j。
```

![img](../../studyTechnology/image/dataStructure/有序度.jpg)

对于一个完全有序的数组，比如 1，2，3，4，5，6，有序度就是 **n*(n-1)/2**

我们把这种完全有序的数组的有序度叫作**满有序度**。

>  **逆序度：数组中具有有序关系的元素对的个数**

```
逆序元素对：a[i] > a[j], 如果i < j。
```

**逆序度 = 满有序度 - 有序度**





## 冒泡排序

> 概念

冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换。一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作。



冒泡排序包含两个操作原子，**比较**和**交换**。每交换一次，**有序度**就加 1。不管算法怎么改进，交换次数总是确定的，即为**逆序度，也就是n*(n-1)/2–初始有序度**。

![img](../../studyTechnology/image/dataStructure/冒泡排序.jpg)

```java
    public static void sort5(int[] arr){
        boolean isExchange = true;
        for (int i = 0; i < arr.length; i++) {
            isExchange = true;
            for (int j = 0; j < arr.length-i-1 ; j++) {
                if(arr[j]>arr[j+1]){
                    int temp = arr[j];
                    arr[j] = arr[j+1];
                    arr[j+1] = temp;
                    isExchange = false;
                }
            }
            if (isExchange){
                break;
            }
            System.out.println(Arrays.toString(arr));

        }
    }
```



## 插入排序

![img](../../studyTechnology/image/dataStructure/插入排序.jpg)

插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。重复这个过程，直到未排序区间中元素为空，算法结束。

```java
    /**
     * 插入的数据从后往前的依次和前面的有序比较，如果插入数据小，则将比较的数据后移
     * @param arr
     */
    public static void sort1(int[] arr){
        for (int i = 1; i < arr.length; i++) {
            int value = arr[i];
            int j = i-1;
            for (;j>=0;j--){
                if (value<arr[j]){
                    //数据移动
                    arr[i] = arr[j];
                }else{
                    break;
                }
            }
            //插入数据
            arr[j+1] = value;
        }
    }
```

### 冒泡排序和插入排序哪个更好？

1. 冒泡排序不管怎么优化，元素交换的次数是一个固定值，是原始数据的逆序度。插入排序是同样的，不管怎么优化，元素移动的次数也等于原始数据的逆序度。**冒泡排序和插入排序元素移动的次数是一样的**
2. 从代码实现上来看，冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序需要 3 个赋值操作，而插入排序只需要 1 个。**插入排序每次数据交换只需要一个复制操作，所以交换的时间的总消耗实际要比冒泡排序小。**

### 希尔排序（插入排序的优化版）

> 基本思想

**希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。**

```java
    /**
     * 希尔排序
     * 希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，
     * 当增量减至1时，整个文件恰被分成一组，算法便终止
     * @param arr
     */
    public static void sort2(int[] arr){
        for(int gap = arr.length/2;gap>0;gap/=2){
            for (int i = gap; i < arr.length; i++) {
                int j = i;
                while (j-gap>=0 && arr[j]<arr[j-gap]){
                    //插入排序采用交换法
                    swap(arr,j,j-gap);
                    j-=gap;
                }
            }
        }
    }
    private static void swap(int[] arr,int a,int b){
        arr[a] = arr[a]+arr[b];
        arr[b] = arr[a]-arr[b];
        arr[a] = arr[a]-arr[b];
    }
```

为什么希尔能突破O(n2)的界，可以用逆序数来理解，假设我们要从小到大排序，一个数组中取两个元素如果前面比后面大，则为一个逆序，容易看出**排序的本质就是消除逆序数**，可以证明对于随机数组，逆序数是O(n2)的，而如果采用“交换相邻元素”的办法来消除逆序，**每次正好只消除一个**，**因此必须执行O(n2)的交换次数**，这就是为什么冒泡、插入等算法只能到平方级别的原因，反过来，**基于交换元素的排序要想突破这个下界，必须执行一些比较，交换相隔比较远的元素，使得一次交换能消除多个逆序**。





## 选择排序

选择排序算法的实现思路有点类似插入排序，也分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。

![img](../../studyTechnology/image/dataStructure/选择排序.jpg)

```java
    public static void sort1(int[] arr){
        for (int i = 0; i < arr.length-1; i++) {
            int index = i;
            //找到最小值
            for (int j = i+1; j < arr.length; j++) {
                if(arr[index]>arr[j]){
                    index = j;
                }
            }
            //交换数据
            if(index!=i){
                int temp = arr[index];
                arr[index] = arr[i];
                arr[i] = temp;
            }
        }
    }
```

## 冒泡，插入，选择排序的时间复杂度

![img](../../studyTechnology/image/dataStructure/冒泡，插入，选择排序的时间空间复杂度.jpg)

## 归并排序

> 原理

如果要排序一个数组，我们先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。

![img](../../studyTechnology/image/dataStructure/归并排序.jpg)

归并排序使用的就是**分治思想。**

**分治是一种解决问题的处理思想，递归是一种编程技巧**

```java
    public static void sort1(int[] arr,int start,int end){
        if(start>=end){
            return;
        }
        int mid = (start+end)/2;

        //分治递归
        sort1(arr,start,mid);
        sort1(arr,mid+1,end);

        //合并数组
        int i = start;
        int j = mid+1;
        int k = 0;
        int[] temp = new int[end-start+1];
        while (i<=mid && j<=end){
            if(arr[i]<arr[j]){
                temp[k++] = arr[i++];
            }else{
                temp[k++] = arr[j++];
            }
        }
        //判断比较后是否还有剩余
        while (i<=mid){
            temp[k++] = arr[i++];
        }
        while(j<=end){
            temp[k++] = arr[j++];
        }
        //将temp的值赋值给数组
        for (int l = 0; l < end-start+1; l++) {
            arr[start+l] = temp[l];
        }

    }
```

归并排序的执行效率与要排序的原始数组的有序程度无关，所以其时间复杂度是非常稳定的，不管是最好情况、最坏情况，还是平均情况，**时间复杂度都是 O(nlogn)。**

在任意时刻，CPU 只会有一个函数在执行，也就只会有一个临时的内存空间在使用。临时内存空间最大也不会超过 n 个数据的大小，所以**空间复杂度是 O(n)。**



## 快速排序

> 原理

快排的思想是这样的：如果要排序数组中下标从 p 到 r 之间的一组数据，我们选择 p 到 r 之间的任意一个数据作为 pivot（分区点）。

我们遍历 p 到 r 之间的数据，将小于 pivot 的放到左边，将大于 pivot 的放到右边，将 pivot 放到中间。经过这一步骤之后，数组 p 到 r 之间的数据就被分成了三个部分，前面 p 到 q-1 之间都是小于 pivot 的，中间是 pivot，后面的 q+1 到 r 之间是大于 pivot 的。

![img](../../studyTechnology/image/dataStructure/快速排序.jpg)





归并排序的处理过程是由下到上的，先处理子问题，然后再合并。而快排正好相反，它的处理过程是由上到下的，先分区，然后再处理子问题。

```java
/**
     * 递归实现
     * @param arr
     * @param start
     * @param end
     */
    private static void quickSort(int[] arr,int start,int end){
        //递归结束条件 start大于或者等于end的时候
        if(start>=end){
            return;
        }
        //得到基准元素的位置
        int pivot = partition(arr,start,end);

        //根据基准元素，分成两部分进行递归排序
        quickSort(arr,start,pivot-1);
        quickSort(arr,pivot+1,end);
    }
    /**
     * 分治（双边循环法）
     * @param arr 待交换的数组
     * @param start 起始下标
     * @param end 结束下标
     * @return
     */
    private static int partition(int[] arr ,int start,int end){
        int pivot = arr[start];
        int left = start;
        int right = end;

        while(left<right){

            //控制right指针比较左移
            while (left<right && arr[right]>pivot){
                right--;
            }

            //控制left指针比较右移
            while(left<right && arr[left]<=pivot){
                left++;
            }

            //交换left和right指针所指向的元素
            if(left<right){
                int p = arr[left];
                arr[left] = arr[right];
                arr[right] = p;
            }
        }

        //pivot和指针重合点交换
        arr[start] = arr[left];
        arr[left] = pivot;

        return left;
    }

/**
     * 分治（单边循环法）
     * @param arr 待交换的数组
     * @param start 起始下标
     * @param end 结束下标
     * @return
     */
    private static int partition1(int[] arr,int start,int end){
        //取第一个位置（也可以随机选择位置）的元素为基准元素
        int pivot = arr[start];
        int mark = start;

        for (int i = start+1; i <= end; i++) {
            if(arr[i]<pivot){
                if (mark == i){
                    continue;
                }
                mark++;
                int p = arr[mark];
                arr[mark] = arr[i];
                arr[i] = p;
            }
        }

        arr[start] = arr[mark];
        arr[mark] = pivot;

        return mark;

    }
```





## 桶排序

> 核心思想

将要排序的数据分到几个有序的桶内，每个桶内的数据再进行单独排序。桶内排序完之后，再把每个桶内的数据按照顺序依次取出，组成的序列就是有序的了

![img](../../studyTechnology/image/dataStructure/桶排序.jpg)

> 局限性

- 桶排序对要排序数据的要求是非常苛刻的。

- 要排序的数据需要很容易就能划分成 m 个桶，并且，桶与桶之间有着天然的大小顺序。

- 数据在各个桶之间的分布是比较均匀的。如果数据经过桶的划分之后，有些桶里的数据非常多，有些非常少，很不平均，那桶内数据排序的时间复杂度就不是常量级了
- **桶排序比较适合用在外部排序中。**所谓的外部排序就是数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中。

```java
 /**
     * 1.获取数组的最大值和最小值
     * 2.根据最大值和最小值初始化桶二维数组，以及用来记录每个桶内数据数量的数组
     * 3.将数据分值分配到各个桶中
     * 4.对桶中的数据进行快速排序
     * 5.将数据添加到原数组
     * 桶排序
     *
     * @param arr 数组
     * @param bucketSize 桶容量
     */
    public static void bucketSort(int[] arr, int bucketSize) {
        if (arr.length < 2) {
            return;
        }

        // 数组最小值
        int minValue = arr[0];
        // 数组最大值
        int maxValue = arr[1];
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] < minValue) {
                minValue = arr[i];
            } else if (arr[i] > maxValue) {
                maxValue = arr[i];
            }
        }

        // 桶数量
        int bucketCount = (maxValue - minValue) / bucketSize + 1;
        int[][] buckets = new int[bucketCount][bucketSize];
        int[] indexArr = new int[bucketCount];

        // 将数组中值分配到各个桶里
        for (int i = 0; i < arr.length; i++) {
            int bucketIndex = (arr[i] - minValue) / bucketSize;
            if (indexArr[bucketIndex] == buckets[bucketIndex].length) {
                ensureCapacity(buckets, bucketIndex);
            }
            buckets[bucketIndex][indexArr[bucketIndex]++] = arr[i];
        }

        // 对每个桶进行排序，这里使用了快速排序
        int k = 0;
        for (int i = 0; i < buckets.length; i++) {
            if (indexArr[i] == 0) {
                continue;
            }
            quickSortC(buckets[i], 0, indexArr[i] - 1);
            for (int j = 0; j < indexArr[i]; j++) {
                arr[k++] = buckets[i][j];
            }
        }
    }

    /**
     * 数组扩容
     *
     * @param buckets
     * @param bucketIndex
     */
    private static void ensureCapacity(int[][] buckets, int bucketIndex) {
        int[] tempArr = buckets[bucketIndex];
        int[] newArr = new int[tempArr.length * 2];
        for (int j = 0; j < tempArr.length; j++) {
            newArr[j] = tempArr[j];
        }
        buckets[bucketIndex] = newArr;
    }

    /**
     * 快速排序递归函数
     *
     * @param arr
     * @param p
     * @param r
     */
    private static void quickSortC(int[] arr, int p, int r) {
        if (p >= r) {
            return;
        }

        int q = partition(arr, p, r);
        quickSortC(arr, p, q - 1);
        quickSortC(arr, q + 1, r);
    }

    /**
     * 分区函数
     *
     * @param arr
     * @param p
     * @param r
     * @return 分区点位置
     */
    private static int partition(int[] arr, int p, int r) {
        int pivot = arr[r];
        int i = p;
        for (int j = p; j < r; j++) {
            if (arr[j] <= pivot) {
                swap(arr, i, j);
                i++;
            }
        }

        swap(arr, i, r);
        return i;
    }

    /**
     * 交换
     *
     * @param arr
     * @param i
     * @param j
     */
    private static void swap(int[] arr, int i, int j) {
        if (i == j) {
            return;
        }

        int tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }
```





## 计数排序

**计数排序其实是桶排序的一种特殊情况**

![img](../../studyTechnology/image/dataStructure/计数排序.jpg)

**计数排序只能用在数据范围不大的场景中，如果数据范围 k 比要排序的数据 n 大很多，就不适合用计数排序了。而且，计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数。**



```java
public static int[] countSort1(int[] array){
        //1.得到数列的最小值和最大值
        int max = array[0];
        int min = array[0];
        for (int i = 0; i < array.length; i++) {
            if(array[i]>max){
                max = array[i];
            }
            if(array[i]<min){
                min = array[i];
            }
        }

        int d = max-min;
        //2.创建统计数组，并统计对应元素的个数
        int[] countArray = new int[d+1];
        for (int i = 0; i < array.length; i++) {
            countArray[array[i]-min]++;
        }
        System.out.println("2--countArray:"+Arrays.toString(countArray));
        //3.统计数组做变形，后面的元素等于前面的元素之和
        for (int i = 1; i < countArray.length; i++) {
            countArray[i] += countArray[i-1];
        }
        System.out.println("3--countArray:"+Arrays.toString(countArray));
        //4.倒序遍历原始数列，从统计组中找到正确位置，输出到结果数组
        int[] sortArray = new int[array.length];
        for (int i = array.length-1; i >=0 ; i--) {
            System.out.println("4--countArray:"+Arrays.toString(countArray));
            System.out.println("4--sortArray:"+Arrays.toString(sortArray));
            System.out.println("4--i:"+i);

            sortArray[countArray[array[i]-min]-1] = array[i];
            countArray[array[i]-min]--;

            System.out.println("-------------------------");
        }
        System.out.println("4--countArray:"+Arrays.toString(countArray));
        System.out.println("4--sortArray:"+Arrays.toString(sortArray));
        return sortArray;
    }
```









## 基数排序（Radix sort）

基数排序对要排序的数据是有要求的，需要可以分割出独立的“位”来比较，而且位之间有递进的关系，如果 a 数据的高位比 b 数据大，那剩下的低位就不用比较了。除此之外，每一位的数据范围不能太大，要可以用线性排序算法来排序，否则，基数排序的时间复杂度就无法做到 O(n) 了。

![img](../../studyTechnology/image/dataStructure/基数排序.jpg)

```java
/**
     * 1.获取数组的最大值
     * 2.从个位开始，对数组按照“指数”进行排序
     * @param arr
     */
    public static void radixSort(int[] arr){
        int max = arr[0];
        for (int i = 0; i < arr.length; i++) {
            if (arr[i]>max){
                max = arr[i];
            }
        }

        //从个位开始，对数组按照“指数”进行排序
        for(int exp = 1;max/exp>0;exp*=10){

        }
    }

    /**
     * 计数排序-对数组按照“某个位数”进行排序
     * @param arr
     * @param exp
     */
    public static void countingSort(int[] arr,int exp){
        if (arr.length<=1){
            return;
        }

        //计算每个元素的个数
        int[] c = new int[10];
        for (int i = 0; i < arr.length; i++) {
            c[(arr[i]/exp)%10]++;
        }

        //计算排序后的位置
        for (int i = 1; i < c.length; i++) {
            c[i]+=c[i-1];
        }

        //临时数组r 存储排序之后的结果
        int[] r = new int[arr.length];
        for (int i = arr.length-1; i >=0 ; i--) {
            r[c[(arr[i]/exp)%10]-1] = arr[i];
            c[(arr[i]/exp)%10] --;
        }

        for (int i = 0; i < arr.length; i++) {
            arr[i] = r[i];
        }

    }
```



## 如何选择合适的排序算法





![img](../../studyTechnology/image/dataStructure/排序算法总结.jpg)

根据不同的需求场景，选择使用不同的排序算法



## Arrays.sort() 源码解析

```java
//长度小于286优先使用快速排序
//长度小于47优先使用插入排序





/**
     * Sorts the specified array into ascending numerical order.
     * 将数组按照升序排序
     * <p>Implementation note: The sorting algorithm is a Dual-Pivot Quicksort
     * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
     * offers O(n log(n)) performance on many data sets that cause other
     * quicksorts to degrade to quadratic performance, and is typically
     * faster than traditional (one-pivot) Quicksort implementations.
     *
     * @param a the array to be sorted
     */
    public static void sort(int[] a) {
        DualPivotQuicksort.sort(a, 0, a.length - 1, null, 0, 0);
    }


	/**
     * Sorts the specified range of the array using the given
     * workspace array slice if possible for merging
     *
     * @param a the array to be sorted
     * @param left the index of the first element, inclusive, to be sorted
     * @param right the index of the last element, inclusive, to be sorted
     * @param work a workspace array (slice)
     * @param workBase origin of usable space in work array
     * @param workLen usable size of work array
     */
    static void sort(int[] a, int left, int right,
                     int[] work, int workBase, int workLen) {
        // Use Quicksort on small arrays
        //长度小于286优先使用快速排序
        if (right - left < QUICKSORT_THRESHOLD) {
            sort(a, left, right, true);
            return;
        }

        /*
         * Index run[i] is the start of i-th run
         * (ascending or descending sequence).
         */
        int[] run = new int[MAX_RUN_COUNT + 1];
        int count = 0; run[0] = left;

        // Check if the array is nearly sorted
        for (int k = left; k < right; run[count] = k) {
            if (a[k] < a[k + 1]) { // ascending
                while (++k <= right && a[k - 1] <= a[k]);
            } else if (a[k] > a[k + 1]) { // descending
                while (++k <= right && a[k - 1] >= a[k]);
                for (int lo = run[count] - 1, hi = k; ++lo < --hi; ) {
                    int t = a[lo]; a[lo] = a[hi]; a[hi] = t;
                }
            } else { // equal
                for (int m = MAX_RUN_LENGTH; ++k <= right && a[k - 1] == a[k]; ) {
                    if (--m == 0) {
                        sort(a, left, right, true);
                        return;
                    }
                }
            }

            /*
             * The array is not highly structured,
             * use Quicksort instead of merge sort.
             */
            if (++count == MAX_RUN_COUNT) {
                sort(a, left, right, true);
                return;
            }
        }

        // Check special cases
        // Implementation note: variable "right" is increased by 1.
        if (run[count] == right++) { // The last run contains one element
            run[++count] = right;
        } else if (count == 1) { // The array is already sorted
            return;
        }

        // Determine alternation base for merge
        byte odd = 0;
        for (int n = 1; (n <<= 1) < count; odd ^= 1);

        // Use or create temporary array b for merging
        int[] b;                 // temp array; alternates with a
        int ao, bo;              // array offsets from 'left'
        int blen = right - left; // space needed for b
        if (work == null || workLen < blen || workBase + blen > work.length) {
            work = new int[blen];
            workBase = 0;
        }
        if (odd == 0) {
            System.arraycopy(a, left, work, workBase, blen);
            b = a;
            bo = 0;
            a = work;
            ao = workBase - left;
        } else {
            b = work;
            ao = 0;
            bo = workBase - left;
        }

        // Merging
        for (int last; count > 1; count = last) {
            for (int k = (last = 0) + 2; k <= count; k += 2) {
                int hi = run[k], mi = run[k - 1];
                for (int i = run[k - 2], p = i, q = mi; i < hi; ++i) {
                    if (q >= hi || p < mi && a[p + ao] <= a[q + ao]) {
                        b[i + bo] = a[p++ + ao];
                    } else {
                        b[i + bo] = a[q++ + ao];
                    }
                }
                run[++last] = hi;
            }
            if ((count & 1) != 0) {
                for (int i = right, lo = run[count - 1]; --i >= lo;
                    b[i + bo] = a[i + ao]
                );
                run[++last] = right;
            }
            int[] t = a; a = b; b = t;
            int o = ao; ao = bo; bo = o;
        }
    }
```

